#################################################
### utilities & common subroutines
#################################################

generate_access_key() {			# void
	uuid|tr -d -
}

generate_secret_key() {			# void
	openssl rand -base64 36
}

USERMAP_FIELD_GLOBAL_USERNAME=1
USERMAP_FIELD_LOCAL_USERNAME=2
USERMAP_FIELD_ACCESS_KEY=3

lookup_usermap_by_field_key() {
	awk < "$3" \
		-v key="$2" \
		-v field="$1" \
		-F : \
		'! /^#/ && $field == key { print }'
}

lookup_usermap_by_global_username() {	# global-username mapfile
	lookup_usermap_by_field_key "$USERMAP_FIELD_GLOBAL_USERNAME" "$1" "$2"
}

lookup_usermap_by_local_username() {	# local-username mapfile
	lookup_usermap_by_field_key "$USERMAP_FIELD_LOCAL_USERNAME" "$1" "$2"
}

lookup_usermap_by_access_key() {	# access_key mapfile
	lookup_usermap_by_field_key "$USERMAP_FIELD_ACCESS_KEY" "$1" "$2"
}

get_key_stream() {
	awk \
		-v field="$1" \
		-F : \
		'{ print $field }'
}

get_global_username_stream() {
	get_key_stream "$USERMAP_FIELD_GLOBAL_USERNAME"
}

get_local_username_stream() {
	get_key_stream "$USERMAP_FIELD_LOCAL_USERNAME"
}

get_access_key_stream() {
	get_key_stream "$USERMAP_FIELD_ACCESS_KEY"
}


get_global_username() {
	echo "$1" | get_key_stream "$USERMAP_FIELD_GLOBAL_USERNAME"
}

get_local_username() {
	echo "$1" | get_key_stream "$USERMAP_FIELD_LOCAL_USERNAME"
}

get_access_key() {
	echo "$1" | get_key_stream "$USERMAP_FIELD_ACCESS_KEY"
}


filter_add_to_usermap() {
	awk \
		-v global_username="$1" \
		-v local_username="$2" \
		-v access_key="$3" \
		-v usermap_field_global_username="$USERMAP_FIELD_GLOBAL_USERNAME" \
		-v usermap_field_local_username="$USERMAP_FIELD_LOCAL_USERNAME" \
		-v usermap_field_access_key="$USERMAP_FIELD_ACCESS_KEY" \
		-F : \
		'{ print }
		 END {	f[usermap_field_global_username] = global_username
			f[usermap_field_local_username] = local_username
			f[usermap_field_access_key] = access_key
			printf("%s:%s:%s\n", f[1], f[2], f[3]) }'
}

PORTMAP_FIELD_LOCAL_USERNAME=1
PORTMAP_FIELD_PORT=2
PORTMAP_FIELD_PID=3

lookup_portmap() {
	if [ -n "$2" ]; then
		echo "$2"
		return 0
	fi
	< "$GFARMS3_USER_PORT_MAP" awk \
		-v local_username="$1" \
		-v portmap_field_local_username="$PORTMAP_FIELD_LOCAL_USERNAME" \
		-v portmap_field_port="$PORTMAP_FIELD_PORT" \
		-v portmap_field_pid="$PORTMAP_FIELD_PID" \
		-F : \
		'$portmap_field_local_username == local_username { printf("%s:%s\n", $portmap_field_port, $portmap_field_pid) }'
}

update_portmap() {
	local tmpfile=$(mktemp "$GFARMS3_USER_PORT_MAP.XXXXXX") || return 1
	(flock 3
		< "$GFARMS3_USER_PORT_MAP" "$@" > "$tmpfile"
		chmod 644 "$tmpfile" "$GFARMS3_USER_PORT_MAP"
		mv $tmpfile "$GFARMS3_USER_PORT_MAP"
		chmod 444 "$GFARMS3_USER_PORT_MAP"
	) 3> $GFARM_S3_LOCKDIR/update_portmap.lock
}

add_to_portmap() {
	update_portmap filter_add_to_portmap "$@"
}

del_from_portmap() {
	update_portmap filter_del_from_portmap "$@"
}

#################################################
### gfarm-s3-configtest
#################################################

list_unused_ports() {
	if [ -n "$2" ]; then
		echo "$2"
		return 0
	fi
	local ports_in_use=$(mktemp $GFARM_S3_TMP/tmpfile.XXXXXX) || return 1
	< "$GFARMS3_USER_PORT_MAP" filter_list_occupied_ports "$1" | sort > "$ports_in_use"
	< "$GFARMS3_USER_PORT_MAP" filter_list_occupied_port_by_a_user "$1"
	seq $GFARMS3_PORT_MIN 1 $GFARMS3_PORT_MAX | sort | comm -23 - "$ports_in_use" | sort -n
	rm -f "$ports_in_use"
}

filter_add_to_portmap() {
	awk \
		-v local_username="$1" \
		-v port="$2" \
		-v pid="$3" \
		-v portmap_field_local_username="$PORTMAP_FIELD_LOCAL_USERNAME" \
		-v portmap_field_port="$PORTMAP_FIELD_PORT" \
		-v portmap_field_pid="$PORTMAP_FIELD_PID" \
		-F : \
		'$portmap_field_local_username != local_username { print }
		 END {	f[portmap_field_local_username] = local_username
			f[portmap_field_port] = port
			f[portmap_field_pid] = pid
			printf("%s:%s:%s\n", f[1], f[2], f[3]) }'
}

filter_del_from_portmap() {
	awk \
		-v local_username="$1" \
		-v portmap_field_local_username="$PORTMAP_FIELD_LOCAL_USERNAME" \
		-F : \
		'$portmap_field_local_username != local_username { print }'
}

filter_list_occupied_port_by_a_user() {
	awk \
		-v local_username="$1" \
		-v portmap_field_local_username="$PORTMAP_FIELD_LOCAL_USERNAME" \
		-v portmap_field_port="$PORTMAP_FIELD_PORT" \
		-F : \
		'$portmap_field_local_username == local_username { print $portmap_field_port }'
}

filter_list_occupied_ports() {
	awk \
		-v portmap_field_port="$PORTMAP_FIELD_PORT" \
		-F : \
		'{ print $portmap_field_port }'
}

filter_list_users_in_portmap() {
	awk \
		-v portmap_field_local_username="$PORTMAP_FIELD_LOCAL_USERNAME" \
		-F : \
		'{ print $portmap_field_local_username }'
}

configtest_format_test() {
	local tmpfile=$(mktemp $GFARM_S3_TMP/gfarm-s3-configtest.XXXXXX) || return 1
	local status=0
	grep -v '^#' "$1"|
	grep -v '^[^:][^:]*:[^:][^:]*:[^:][^:]*$' >$tmpfile
	if [ -s $tmpfile ]; then
		echo "MALFORMED ENTRY:" 1>&2
		cat $tmpfile 1>&2
		status=1
	fi
	rm $tmpfile
	return $status
}

configtest_global_username_test() {
	local tmpfile=$(mktemp $GFARM_S3_TMP/gfarm-s3-configtest.XXXXXX) || return 1
	local status=0
	grep -v '^#' "$1"|
	get_global_username_stream|sort|uniq -d>$tmpfile
	if [ -s $tmpfile ]; then
		echo "DUPLICATED GLOBAL USERNAME:" 1>&2
		cat $tmpfile 1>&2
		status=1
	fi
	rm $tmpfile
	return $status
}

check_global_username() {
	#echo "checking global_username: $1" 1>&2
	if [ -z "$1" ]; then
		## empty string
		return 1
	fi
	return 0
}

check_local_username() {
	#echo "checking local_username: $1" 1>&2
	if [ -z "$1" ]; then
		## empty string
		return 1
	fi
	return 0
}

check_access_key() {
	#echo "checking access_key: $1" 1>&2
	if ! echo "$1" | grep -q '^[a-zA-Z0-9_]*$'; then
		echo "invalid char in access_key. (a-zA-Z0-9_)" 1>&2
		return 1
	fi
	len=$(expr length "$1")
	if ! [ $len -ge $GFARM_S3_ACCESS_KEY_MIN_LEN -a $len -le 128 ]; then
		echo "access_key length must be $GFARM_S3_ACCESS_KEY_MIN_LEN .. 128" 1>&2
		return 1
	fi
	return 0
}

configtest_global_username_test_2() {
	local tmpfile=$(mktemp $GFARM_S3_TMP/gfarm-s3-configtest.XXXXXX) || return 1
	local status=0
	grep -v '^#' "$1"|
	get_global_username_stream|grep '^[ 	]*$'>$tmpfile
	if [ -s $tmpfile ]; then
		echo "MALFORMED GLOBAL USERNAME:" 1>&2
		cat $tmpfile 1>&2
		status=1
	fi
	for global_username in $(grep -v '^#' "$1"|get_global_username_stream); do
		if ! check_global_username "$global_username"; then
			status=1
		fi
	done
	rm $tmpfile
	return $status
}

configtest_local_username_test() {
	local tmpfile=$(mktemp $GFARM_S3_TMP/gfarm-s3-configtest.XXXXXX) || return 1
	local status=0
	grep -v '^#' "$1"|
	get_local_username_stream|sort|uniq -d>$tmpfile
	if [ -s $tmpfile ]; then
		echo "DUPLICATED LOCAL USERNAME:" 1>&2
		cat $tmpfile 1>&2
		status=1
	fi
	for local_username in $(grep -v '^#' "$1"|get_local_username_stream); do
		if ! check_local_username "$local_username"; then
			status=1
		fi
	done
	rm $tmpfile
	return $status
}

configtest_access_key_test() {
	local tmpfile=$(mktemp $GFARM_S3_TMP/gfarm-s3-configtest.XXXXXX) || return 1
	local status=0
	grep -v '^#' "$1"|
	get_access_key_stream|sort|uniq -d>$tmpfile
	if [ -s $tmpfile ]; then
		echo "DUPLICATED ACCESS_KEY:" 1>&2
		cat $tmpfile 1>&2
		status=1
	fi
	for access_key in $(grep -v '^#' "$1"|get_access_key_stream); do
		#echo "checking access_key: $access_key" 1>&2
		if ! check_access_key "$access_key"; then
			status=1
		fi
	done
	rm $tmpfile
	return $status
}

configtest_local_user_exisence_test() {
	local tmpfile=$(mktemp $GFARM_S3_TMP/gfarm-s3-configtest.XXXXXX) || return 1
	local status=0
	for user in $(grep -v '^#' "$1"|get_local_username_stream); do
		if ! id $user >/dev/null; then
			echo "NO SUCH LOCALUSER: $user" 1>&2
			status=1
		fi
	done
	rm $tmpfile
	return $status
}

configtest_all() {
	local status=0

	echo configtest_all: 1>&2
	#sed 's/^/> /' "$1" 1>&2

	if ! configtest_format_test "$1"; then return 1; fi
	# when format_test fails, the following tests will not be performed
	if ! configtest_global_username_test "$1"; then status=1; fi
	if ! configtest_global_username_test_2 "$1"; then status=1; fi
	if ! configtest_local_username_test "$1"; then status=1; fi
	if ! configtest_access_key_test "$1"; then status=1; fi
	if ! configtest_local_user_exisence_test "$1"; then status=1; fi
	echo status=$status 1>&2
	return $status
}

update_usermap() {
	local tmpfile=$(mktemp "$GFARM_S3_TMP/update_usermap.XXXXXX") || return 1
	(flock 3
		if ! "$@" "$GFARMS3_LOCAL_USER_MAP" "$tmpfile"; then
			echo edit failed 1>&2
			echo "update_usermap: $GFARMS3_LOCAL_USER_MAP: unchanged" 1>&2
			rm -f "$tmpfile"
			return 1
		fi
		if cmp "$GFARMS3_LOCAL_USER_MAP" "$tmpfile" >/dev/null; then
			echo no edit 1>&2
			echo "update_usermap: $GFARMS3_LOCAL_USER_MAP: unchanged" 1>&2
			rm -f "$tmpfile"
			return 1
		fi
		if ! configtest_all "$tmpfile"; then
			echo configtest failed 1>&2
			echo "update_usermap: $GFARMS3_LOCAL_USER_MAP: unchanged" 1>&2
			rm -f "$tmpfile"
			return 1
		fi

		local users=$(users_subject_to_be_stopped "$GFARMS3_LOCAL_USER_MAP" "$tmpfile" "$GFARMS3_USER_PORT_MAP")
		for user in $users; do
			echo "STOP [$user]'s MinIO" 1>&2
			if ! stop_per_user_server "$user"; then
				echo "STOP FAILED" 1>&2
			fi

			need_update_revproxy=1
			del_from_portmap "$user"
		done
		if [ -n "$users" ]; then
			update_reverse_proxy
		fi

		cp -fp $GFARMS3_LOCAL_USER_MAP $GFARMS3_LOCAL_USER_MAP.bak
		chmod 600 $GFARMS3_LOCAL_USER_MAP.bak
		chmod 644 "$tmpfile" "$GFARMS3_LOCAL_USER_MAP"
		mv "$tmpfile" "$GFARMS3_LOCAL_USER_MAP"
		chmod 444 "$GFARMS3_LOCAL_USER_MAP"
	) 3> $GFARM_S3_LOCKDIR/update_usermap.lock
}

# - MinIO is running &&
#   (local username is deleted ||
#    access_key of a local user is changed ||
#    global_user of a local user is changed)
#   => stop MinIO

sort_usermap_by_local_username() {
	sort -t: -k "$USERMAP_FIELD_LOCAL_USERNAME"
}

list_changed_local_user() {
	local tmp1=$(mktemp $GFARM_S3_TMP/gfarm-s3-diff-local-usermap.XXXXXX) || exit 1
	local tmp2=$(mktemp $GFARM_S3_TMP/gfarm-s3-diff-local-usermap.XXXXXX) || exit 1
	grep -v '^#' "$1" | sort_usermap_by_local_username > $tmp1
	grep -v '^#' "$2" | sort_usermap_by_local_username > $tmp2

	join -t: -1$USERMAP_FIELD_LOCAL_USERNAME -2$USERMAP_FIELD_LOCAL_USERNAME \
		-o "\
1.$USERMAP_FIELD_LOCAL_USERNAME,\
1.$USERMAP_FIELD_GLOBAL_USERNAME,\
2.$USERMAP_FIELD_GLOBAL_USERNAME,\
1.$USERMAP_FIELD_ACCESS_KEY,\
2.$USERMAP_FIELD_ACCESS_KEY" \
		$tmp1 $tmp2 |
	awk -F : '$2 != $3 || $4 != $5 { print $1 }'
	rm -f $tmp1 $tmp2
}

extract_local_username() {
	grep -v '^#' | get_local_username_stream
}

list_removed_local_user() {
	local tmp1=$(mktemp $GFARM_S3_TMP/gfarm-s3-diff-local-usermap.XXXXXX) || exit 1
	local tmp2=$(mktemp $GFARM_S3_TMP/gfarm-s3-diff-local-usermap.XXXXXX) || exit 1
	< "$1" extract_local_username | sort > $tmp1
	< "$2" extract_local_username | sort > $tmp2
	comm -23 $tmp1 $tmp2
	rm -f $tmp1 $tmp2
}

users_subject_to_be_stopped() {
	local modified_user_tmp=$(mktemp $GFARM_S3_TMP/modified_user_tmp.XXXXXX) || exit 1
	(list_changed_local_user "$1" "$2"
	 list_removed_local_user "$1" "$2")|sort|uniq > $modified_user_tmp

	local pormap_users_tmp=$(mktemp $GFARM_S3_TMP/pormap_users_tmp.XXXXXX) || exit 1
	< "$3" filter_list_users_in_portmap |sort > $pormap_users_tmp

	comm -12 $modified_user_tmp $pormap_users_tmp
	rm -f $modified_user_tmp $pormap_users_tmp
}

#################################################
### gfarm-s3-login
#################################################

mysudo() {
	local iflag=
	if [ x$1 = x-i ]; then
		iflag=-i
		shift
	fi
	local local_user=$1
	shift
	if [ -z "$local_user" ]; then
		#echo sudo $iflag "$@" 1>&2
		sudo $iflag "$@"
	else
		#echo sudo $iflag -u "$local_user" "$@" 1>&2
		sudo $iflag -u "$local_user" "$@"
	fi
}

check_nopasswd() {
	local local_user="$1"
	echo dummy1 |
	mysudo "$local_user" $GRID_PROXY_INIT -pwstdin 1>&2
	if [ $? != 0 ]; then
		return 1
	fi
	echo dummy2 |
	mysudo "$local_user" $GRID_PROXY_INIT -pwstdin 1>&2
	if [ $? != 0 ]; then
		return 1
	fi
	return 0
}

challenge_auth() {
	local global_username="$1"
	local user_provided_key="$2"
	local local_user="$3"
	local res

	export GLOBUS_GSSAPI_NAME_COMPATIBILITY="HYBRID"

#	echo challenge_auth "$@" 1>&2

	case $GFARMS3_LOGIN_METHOD in
	*myproxy-logon*)
		echo "$user_provided_key" |
		res=$(mysudo "$local_user" $MYPROXY_LOGON -S \
			${MYPROXY_SERVER:+-s "$MYPROXY_SERVER"} \
			-l "$global_username" \
			${PROXY_LIFETIME:+-t "$PROXY_LIFETIME"} 2>&1)
		if [ $? = 0 ]; then
			echo SUCCESS $MYPROXY_LOGON 1>&2
			logger -i -p local7.debug -t gfarm-s3-minio-web:challenge_auth "myproxy-logon: $local_user SUCCESS $res"
			echo myproxy-logon
			return 0
		else
			echo FAIL $MYPROXY_LOGON 1>&2
			logger -i -p local7.debug -t gfarm-s3-minio-web:challenge_auth "myproxy-logon: $local_user FAIL $res"
		fi
		;;
	esac

	case $GFARMS3_LOGIN_METHOD in
	*grid-proxy-init*)
		if check_nopasswd "$local_user"; then
			echo SKIP $GRID_PROXY_INIT 1>&2
			logger -i -p local7.debug -t gfarm-s3-minio-web:challenge_auth "grid-proxy-init: $local_user SKIP"
		else
			res=$(echo "$user_provided_key" |
				mysudo "$local_user" $GRID_PROXY_INIT -pwstdin 2>&1)
			if [ $? = 0 ]; then
				echo SUCCESS $GRID_PROXY_INIT 1>&2
				logger -i -p local7.debug -t gfarm-s3-minio-web:challenge_auth "grid-proxy-init: $local_user SUCCESS $res"
				echo grid-proxy-init
				return 0
			else
				echo FAIL $GRID_PROXY_INIT 1>&2
				logger -i -p local7.debug -t gfarm-s3-minio-web:challenge_auth "grid-proxy-init: $local_user FAIL $res"
			fi
		fi
		;;
	esac

	case $GFARMS3_LOGIN_METHOD in
	*gfarm-shared-key*)
		local tmpfile=$(mktemp) || return 1
		user_key=$(mysudo "$local_user" $GFARM_S3_BIN/gfarm-s3-sharedsecret-password 2>$tmpfile)
		res=$(cat $tmpfile)
		rm $tmpfile
		if [ "$user_provided_key" = "$user_key" ]; then
			echo SUCCESS gfkey digest 1>&2
			logger -i -p local7.debug -t gfarm-s3-minio-web:challenge_auth "gfarm-shared-key: $local_user SUCCESS $res"
			echo gfkey
			return 0
		else
			echo FAIL gfkey digest 1>&2
			logger -i -p local7.debug -t gfarm-s3-minio-web:challenge_auth "gfarm-shared-key: $local_user FAIL $res"
		fi
		;;
	esac

	return 1
}

spawn_per_user_server() {	# local_username
	local user="$1"
	local gfarm_shared_dir="$2"
	local usermap_entry=$(lookup_usermap_by_local_username "$user" "$GFARMS3_LOCAL_USER_MAP")
	if [ -z "$usermap_entry" ]; then
		echo "user not found: $user" 1>&2
		return 1
	fi
	local local_username=$(get_local_username "$usermap_entry")
	local access_key=$(get_access_key "$usermap_entry")
	## assert $user == $local_username
	if ! local port=$(mysudo "$user" $GFARM_S3_BIN/gfarm-s3-server --start --access_key "$access_key" --gfarm_shared_dir "$gfarm_shared_dir"); then
		retrun 1
	fi
	local status=0

	if [ -n "$port" ]; then
		echo "MinIO started" 1>&2
		## No need to check `port' confliction,
		## as a port # that returned by gfarm-s3-server is
		## actually allocated for current user.
		if ! add_to_portmap "$local_username" "${port%:*}" "${port#*:}"; then
			status=3
		fi
		if ! update_reverse_proxy; then
			status=2
		fi
	else
		echo "MinIO is already running" 1>&2
	fi
	return $status
}

stop_per_user_server() {	# local_username
	local user="$1"
	local usermap_entry=$(lookup_usermap_by_local_username "$user" "$GFARMS3_LOCAL_USER_MAP")
	if [ -z "$usermap_entry" ]; then
		echo "user not found: $user" 1>&2
		return 1
	fi
	local local_username=$(get_local_username "$usermap_entry")
	## assert $user == $local_username
	local access_key=$(get_access_key "$usermap_entry")
	local status=0
	if ! local port=$(mysudo "$user" $GFARM_S3_BIN/gfarm-s3-server --stop --access_key "$access_key"); then
		echo "Stop MinIO failed" 1>&2
		status=1
		## FALLTHRU
	fi
### TODO (low priority):
### We should update gfarm_s3_user_port_map here:
### erase pid from entry (set to empty), but keep username and port number
	return $status
}

get_s3_server_status() {	# local_username
	local user="$1"
	local usermap_entry=$(lookup_usermap_by_local_username "$user" "$GFARMS3_LOCAL_USER_MAP")
	if [ -z "$usermap_entry" ]; then
		echo "user not found: $user" 1>&2
		return 1
	fi
	local local_username=$(get_local_username "$usermap_entry")
	## assert $user == $local_username
	local access_key=$(get_access_key "$usermap_entry")
	mysudo "$user" $GFARM_S3_BIN/gfarm-s3-server --status --access_key "$access_key"
}

get_s3_server_status_quick() {	# local_username
	local user="$1"
	local usermap_entry=$(lookup_usermap_by_local_username "$user" "$GFARMS3_LOCAL_USER_MAP")
	if [ -z "$usermap_entry" ]; then
		echo "user not found: $user" 1>&2
		return 1
	fi
	local local_username=$(get_local_username "$usermap_entry")
	## assert $user == $local_username
	local access_key=$(get_access_key "$usermap_entry")
	status_server_quick "$user"
	#mysudo "$user" $GFARM_S3_BIN/gfarm-s3-server --status-quick --access_key "$access_key"
}

get_per_user_secret_key() {
	local user="$1"
	local usermap_entry=$(lookup_usermap_by_local_username "$user" "$GFARMS3_LOCAL_USER_MAP")
	if [ -z "$usermap_entry" ]; then
		echo "user not found: $user" 1>&2
		return 1
	fi
	local local_username=$(get_local_username "$usermap_entry")
	## assert $user == $local_username
	mysudo "$user" $GFARM_S3_BIN/gfarm-s3-server --show-secret-key
}

regenerate_secret_key() {
	local user="$1"
	local usermap_entry=$(lookup_usermap_by_local_username "$user" "$GFARMS3_LOCAL_USER_MAP")
	if [ -z "$usermap_entry" ]; then
		echo "user not found: $user" 1>&2
		return 1
	fi
	local local_username=$(get_local_username "$usermap_entry")
	## assert $user == $local_username
	mysudo "$user" $GFARM_S3_BIN/gfarm-s3-server --regenerate-secret-key
}

certificate_timeleft_grid_proxy_info() {
	local expiration_date=-1
	local timeleft
	local local_username="$1"
	if ! timeleft=$(mysudo "$local_username" $GRID_PROXY_INFO -timeleft); then
		return 1
	fi
	if [ x"$timeleft" != x"-1" ]; then
		local current_time=$(date +%s)
		expiration_date=$((timeleft + current_time))
	fi
	echo "$expiration_date"
}

certificate_timeleft_gfkey() {
	local v
	local local_username="$1"
	if ! v=$(mysudo "$local_username" $GFKEY -e); then
		return 1
	fi
	date --date="${v#expiration time is }" +%s
}

get_expiration_date() {
	local local_username="$1"
	local authenticated_method="$2"
	case $authenticated_method in
	myproxy-logon|grid-proxy-init)
		echo $(certificate_timeleft_grid_proxy_info "$local_username");;
	gfkey)
		echo $(certificate_timeleft_gfkey "$local_username");;
	*)
		echo -1;;
	esac
}

gfarm_shared_dir_path() {
	local gfarm_shared_dir="$1"
	local global_username="$2"
	if [ -n "$gfarm_shared_dir" ]; then
		echo "$gfarm_shared_dir"
	else
		echo "$GFARMS3_GFARM_SHARED_DIR/$global_username"
	fi
}

#################################################
### gfarm-s3-update-reverse-proxy
#################################################

sort_usermap_by_local_username() {
	sort -t: -k "$USERMAP_FIELD_LOCAL_USERNAME"
}

sort_portmap_by_local_username() {
	sort -t: -k "$PORTMAP_FIELD_LOCAL_USERNAME"
}

generate_apache_conf() {
	local local_user_map_tmp=$(mktemp $GFARM_S3_TMP/gfarm-s3-update-reverse-proxy.XXXXXX) || return 1
	local user_port_map_tmp=$(mktemp $GFARM_S3_TMP/gfarm-s3-update-reverse-proxy.XXXXXX) || return 1
	grep -v "^#" "$GFARMS3_LOCAL_USER_MAP" | sort_usermap_by_local_username >$local_user_map_tmp
	grep -v "^#" "$GFARMS3_USER_PORT_MAP" | sort_portmap_by_local_username >$user_port_map_tmp
	join -t: -1"$USERMAP_FIELD_LOCAL_USERNAME" -2"$PORTMAP_FIELD_LOCAL_USERNAME" \
		-o "1.$USERMAP_FIELD_ACCESS_KEY,2.$PORTMAP_FIELD_PORT" \
		$local_user_map_tmp $user_port_map_tmp | awk \
		-F : \
		'! /^#/ {
			printf("RewriteCond \"%%{HTTP:Authorization}\" \"Credential=%s/\"\n", $1)
			printf("RewriteRule \"^/(.*)$\" \"http://127.0.0.1:%s/$1\" [P]\n", $2)
		}'
	rm $local_user_map_tmp $user_port_map_tmp
}

generate_reverse_proxy_routes() {
	local local_user_map_tmp=$(mktemp $GFARM_S3_TMP/gfarm-s3-update-reverse-proxy.XXXXXX) || return 1
	local user_port_map_tmp=$(mktemp $GFARM_S3_TMP/gfarm-s3-update-reverse-proxy.XXXXXX) || return 1
	grep -v "^#" "$GFARMS3_LOCAL_USER_MAP" | sort_usermap_by_local_username >$local_user_map_tmp
	grep -v "^#" "$GFARMS3_USER_PORT_MAP" | sort_portmap_by_local_username >$user_port_map_tmp
	join -t: -1"$USERMAP_FIELD_LOCAL_USERNAME" -2"$PORTMAP_FIELD_LOCAL_USERNAME" \
		-o "1.$USERMAP_FIELD_ACCESS_KEY,2.$PORTMAP_FIELD_PORT" \
		$local_user_map_tmp $user_port_map_tmp | awk \
		-F : \
		'! /^#/ {
			printf("%s\thttp://127.0.0.1:%s\n", $1, $2)
		}'
	rm $local_user_map_tmp $user_port_map_tmp
}

generate_nginx_conf() {
	return 0
}

restart_apache() {
	#local how=restart
	local how=graceful
	sudo $APACHECTL $how
}

restart_nginx() {
	return 0
}

update_reverse_proxy() {
	local tmpfile=$(mktemp "$GFARMS3_APACHE_REWRITE_CONF.XXXXXX") || return 1
	local status=0
	if ! generate_apache_conf > "$tmpfile"; then
		return 1
	fi

	if cmp "$tmpfile" "$GFARMS3_APACHE_REWRITE_CONF" >/dev/null; then
		echo "no change" 1>&2
		rm "$tmpfile"
	else
		mv "$tmpfile" "$GFARMS3_APACHE_REWRITE_CONF"
		if ! restart_apache; then
			status=1
		fi
	fi

	local tmpfile=$(mktemp "$GFARMS3_REVERSE_PROXY_ROUTES.XXXXXX") || return 1

	if ! generate_reverse_proxy_routes > "$tmpfile"; then
		return 1
	fi

	if cmp "$tmpfile" "$GFARMS3_REVERSE_PROXY_ROUTES" >/dev/null; then
		echo "no change" 1>&2
		rm "$tmpfile"
	else
		chmod og+r "$tmpfile"
		mv "$tmpfile" "$GFARMS3_REVERSE_PROXY_ROUTES"
	fi

	return $status
}

#################################################
### gfarm-s3-server
#################################################

mymc_init() {
	MC_CONFIG_DIR=$(mktemp -d $GFARM_S3_TMP/mc.XXXXXX) || return 1
}

mymc_finish() {
	if [ -z "$MC_CONFIG_DIR" ]; then return 1; fi
	rm -rf "$MC_CONFIG_DIR"
}

mymc() {
	if [ -z "$MC_CONFIG_DIR" ]; then return 1; fi

	r=$($MC_PATH --config-dir "$MC_CONFIG_DIR" "$@" 2>&1)
	status=$?
	logger -i -p local7.debug -t gfarm-s3-minio-web:mymc "[$r]"

	return $status
}

mc_config() {
	local address="$1"
	local ENDPOINT_URL="http://$address"

	mymc config host add \
		"$MC_PROFILE" \
		"$ENDPOINT_URL" \
		"$MINIO_ROOT_USER" \
		"$MINIO_ROOT_PASSWORD" 1>&2
}

mc_stop() {
	mymc admin service stop $MC_PROFILE
}

## @param    (none)
## @envvar   USER  -- cureent user
##           uport -- port to be tried, unless empty strnig
## @return   0 -- success    1 -- fail
## @stdout   (empty)  -- success without spawning MinIO || fail
##           port:pid -- success, MinIO's PID == pid
start_server() {
	local SUCCESS=0
	local RETRY=1

	local gfarm_shared_dir="$1"
	for port in $(list_unused_ports "$USER" "$uport"); do
		try_start_a_server "$gfarm_shared_dir" "$port"
		case $? in
		$SUCCESS) return 0;;
		$RETRY) ;;
		*) echo "UNKNOWN ERROR" 1>&2; return 1;;
		esac
	done
	echo "NO PORT AVAILABLE" 1>&2
	return 1
}

try_start_a_server() {
	local gfarm_shared_dir="$1"
	local port="$2"
	local address=127.0.0.1:"$port"

	local SUCCESS=0
	local RETRY=1
	local ABORT=2
	local GATEWAY=gfarm
	#gfarm_shared_dir=/tmp/nas
	#GFARMS3_GFARM_SHARED_VIRTUAL_NAME=
	#GATEWAY=nas

	if ! mymc_init; then
### case M: mc_init failed
		logger -i -p local7.debug -t gfarm-s3-minio-web:try_start_a_server "[M] mc_init failed"
		return $ABORT
	fi
	if mc_config $address; then
		## MinIO is already running
		## success with empty stdout
		logger -i -p local7.debug -t gfarm-s3-minio-web:try_start_a_server "[S] minio is already running"
		return $SUCCESS
	fi
	mymc_finish
	local tmpfile=$(mktemp $GFARM_S3_TMP/minio-log.XXXXXX) || return $ABORT
	local pidfile=$(mktemp $GFARM_S3_TMP/minio-pid.XXXXXX) || (rm -f $tmpfile; return $ABORT)
	( \
	 export MINIO_GFARMS3_CACHEDIR=$(mktemp -d $GFARMS3_CACHE_BASEDIR/gfarm-s3-XXXXXXXX) || exit 1; \
	 export MINIO_GFARMS3_CACHEDIR_SIZE_MB="$GFARMS3_CACHE_SIZE_MB_PER_USER"; \
	 export GFARMS3_PARTFILE_DIGEST="$GFARMS3_PARTFILE_DIGEST"; \
	 if ! chmod 700 $MINIO_GFARMS3_CACHEDIR; then exit 1; fi; \
	 HOME="$GFARMS3_METADIR" $MINIO_PATH gateway $GATEWAY \
		--address "$address" \
		"$gfarm_shared_dir" \
		$GFARMS3_GFARM_SHARED_VIRTUAL_NAME & \
	 echo "$port:$!" 1>&3; \
	 wait; \
	 rm -rf "$MINIO_GFARMS3_CACHEDIR"; \
	 echo "Minio Exited") <&- >$tmpfile 2>&1 3>$pidfile &
	for i in $(seq 1 1 60); do
		if egrep -l "^(Endpoint|Minio Exited)" $tmpfile 1>&2; then
			## MinIO started, and wrote greeting message to stdout
			## or MinIO exited (for some reason)
			break
		fi
		sleep 1
	done

### case 0: Minio Launched normally
###         Pattern "^Endpoint" is in log
###	    try connect using mc
###         case 4: fail     => ABORT spawning process
###         case 5: SUCCESS
### case 1: Minio Exited  (port is in use)
###         Pattern "ERROR Unable to start the gateway: Specified port is already in use"
###                and
###         pattern "Minio Exited" are in log
###         RETRY start minio using another port
### case 2: Minio Exited  (another reason)
###         Pattern "Minio Exited" is in log
###         ABORT minio spawing process
### case 3: no expected pattern does not appear in log
###         unknown status => kill minil and ABORT spawning process

	if grep -l "^Minio Exited" $tmpfile 1>&2; then

		if ! grep -l "port is already in use" $tmpfile 1>&2; then
			rm -f $tmpfile
			rm -f $pidfile
###			case 2
			logger -i -p local7.debug -t gfarm-s3-minio-web:try_start_a_server "[2] port is in use"
			return $ABORT
		fi

		rm -f $tmpfile
		rm -f $pidfile
###		case 1
		return $RETRY	## temporary error (minio has quit)
	fi

	if ! grep -l "^Endpoint" $tmpfile 1>&2; then
		kill -KILL $(cat $pidfile)
		rm -f $tmpfile
		rm -f $pidfile
###		case 3
		logger -i -p local7.debug -t gfarm-s3-minio-web:try_start_a_server "[3] fatal error (another minio may running)"
		return $ABORT	## fatal error (minio may still running)
	fi

###	case 0

	rm -f $tmpfile
	if ! mymc_init; then
		rm -f $pidfile
### case M: mc_init failed
		logger -i -p local7.debug -t gfarm-s3-minio-web:try_start_a_server "[M] mc_init failed"
		return $ABORT
	fi
	if ! mc_config $address; then
		mymc_finish
		kill -KILL $(cat $pidfile)
		rm -f $pidfile
###		case 0 => case 4
		logger -i -p local7.debug -t gfarm-s3-minio-web:try_start_a_server "[4] fatal error (another minio is running)"
		return $ABORT	## fatal error (minio still running)
	fi
	mymc_finish
	cat $pidfile
	rm -f $pidfile
	logger -i -p local7.debug -t gfarm-s3-minio-web:try_start_a_server "[5] minio started"
###	case 0 => case 5:
	return $SUCCESS
}

stop_server() {
	local port_pid=$(lookup_portmap "$USER" "$uport")
	local port="${port_pid%:*}"
	local pid="${port_pid#*:}"
	if [ -z "$port" -o -z "$pid" ]; then
		return 1
	fi
	try_stop_a_server "$port" "$pid"
}

try_stop_a_server() {
	local port="$1"
	local pid="$2"
	local address=127.0.0.1:"$port"
	if ! mymc_init; then return 1; fi
	if mc_config $address; then
		if mc_stop; then
			mymc_finish

			for i in $(seq 1 1 $GFARM_S3_WAIT_COUNT); do
				if ! kill -0 $pid; then
					return 0
				fi
				sleep 1
			done

			return 0
		fi
	fi
	mymc_finish
	for i in $(seq 1 1 $GFARM_S3_KILL_COUNT); do
		sleep 1
		if ! kill -0 $pid; then
			return 0
		fi
		kill -TERM $pid
	done
	kill -KILL $pid
	return 0
}

status_server() {
	local port_pid=$(lookup_portmap "$USER" "$uport")
	local port="${port_pid%:*}"
	if [ -z "$port" ]; then
		return 1
	fi
	get_server_status "$port"
}

#### this function is called form gfarm-s3-login by first hand
status_server_quick() {
	local local_username="$1"
	local port_pid=$(lookup_portmap "$local_username" "")
	local port="${port_pid%:*}"
	local pid="${port_pid#*:}"
	if [ -z "$port" ]; then
		echo "400 S3 server is not recoreded as running"
		return
	fi
### note: $pid may be empty
	if ! ps -p "$pid" >/dev/null; then
		echo "401 S3 server process is not running"
		return
	fi
	echo "200 S3 sever is running at $port, pid is $pid"
}

get_server_status() {
	local port="$1"
	local address=127.0.0.1:"$port"
	if ! mymc_init; then return 1; fi
	mc_config $address 1>&2
	echo $?
	mymc_finish
}
