#! /bin/bash

set -eu -o pipefail
#set -x

export LANG=C
export LC_CTYPE=C
export LC_COLLATE=C

D=$(dirname $0)
eval $(${D}/gfarm-s3-readconf)
source $GFARM_S3_LIB/gfarm-s3-subr

USAGE="\
usage: $0 [options...] action global-username password
options ::= --gfarm_shared_dir gfarm_shared_dir |
            --authenticated authenticated_method_name |
            --bucket bucket
            --remote_addr remote_addr
            --quiet
action ::= start|stop|restart|resume|status|keygen|info|gfuser|gfgroup|gfls|gfgetfacl|gfsetfacl
"

authenticated=""
gfarm_shared_dir=""
bucket=""
remote_addr=""
quiet=0

while [ $# -gt 0 ]; do
	opt="$1"
	case "$opt" in
	--authenticated) authenticated="$2"; shift;;
	--gfarm_shared_dir) gfarm_shared_dir="$2"; shift;;
	--bucket) bucket="$2"; shift;;
	--remote_addr) remote_addr="$2"; shift;;
	--quiet) quiet=1;;
	*) break;;
	esac
	shift;
done

if [ $# != 3 ]; then
	echo "$USAGE" 1>&2
	exit 1
fi

action="$1"
global_username="$2"
user_password="$3"

case "$action" in start|stop|restart|resume|status|keygen|info|gfuser|gfgroup|gfls|gfgetfacl|gfsetfacl) ;;
*) echo $USAGE 1>&2; exit 1;;
esac

status=failure
reason_error="incorrect username or password"

#TODO
GFARM_S3_LOGIN_CHALLENGE_INTERVAL=5

usermap_entry=$(lookup_usermap_by_global_username "$global_username" "$GFARMS3_LOCAL_USER_MAP")
if [ -z "$usermap_entry" ]; then
	log_info "login failed: user not found in $GFARMS3_LOCAL_USER_MAP: $global_username $remote_addr"
cat <<-EOF
	{
		"status": "$status",
		"reason": "$reason_error"
	}
EOF
	sleep ${GFARM_S3_LOGIN_CHALLENGE_INTERVAL}
	exit 1
fi
local_username=$(get_local_username "$usermap_entry")

if [ -n "$authenticated" ]; then
	authenticated_method="$authenticated"
elif authenticated_method=$(challenge_auth "$global_username" "$user_password" "$local_username"); then
    log_info "login ($authenticated_method): $global_username $local_username $remote_addr"
else
	log_info "login failed: $global_username $local_username $remote_addr"
cat <<-EOF
	{
		"status": "$status",
		"reason": "$reason_error"
	}
EOF
	sleep ${GFARM_S3_LOGIN_CHALLENGE_INTERVAL}
	exit 1
fi

gfarm_shared_dir=$(gfarm_shared_dir_path "$gfarm_shared_dir" "$global_username")

rungf() {
	local local_username="$1"
	local x509_user_proxy=$(get_x509_user_proxy $local_username)
	shift
	mysudo "$local_username" X509_USER_PROXY="$x509_user_proxy" "$@"
}

case "$action" in
start)
	spawn_per_user_server "$local_username" "$gfarm_shared_dir";;
stop)
	stop_per_user_server "$local_username";;
restart)
	stop_per_user_server "$local_username" &&
	spawn_per_user_server "$local_username" "$gfarm_shared_dir";;
resume)
	resume_per_user_server "$local_username" "$gfarm_shared_dir";;
status)
	get_s3_server_status "$local_username";;
keygen)
	regenerate_secret_key "$local_username";;
info)
	true;;
gfuser)
	rungf "$local_username" $GFUSER -l; exit $?;;
gfgroup)
	rungf "$local_username" $GFGROUP; exit $?;;
gfls)
	rungf "$local_username" $GFLS "$gfarm_shared_dir/$bucket"; exit $?;;
gfgetfacl)
	rungf "$local_username" $GFGETFACL "$gfarm_shared_dir/$bucket"; exit $?;;
gfsetfacl)
	### ignore all errors ==> exit 0
	rungf "$local_username" $GFSETFACL -R -b -M - "$gfarm_shared_dir/$bucket"; exit 0;;
esac

exit_status=$?

if [ $exit_status = 0 ]; then
	status=success
	reason="none"
else
	status=failure
	reason="$action exit: code = $exit_status"
fi

if [ $quiet -ne 1 ]; then
cat <<-EOF
	{
		"status": "$status",
		"reason": "$reason",
		"authenticated_method": "$authenticated_method",
		"expiration_date": $(get_expiration_date "$local_username" "$authenticated_method"),
		"global_username": "$(get_global_username "$usermap_entry")",
		"s3server_status": "$(get_s3_server_status_quick "$local_username")",
		"local_username": "$(get_local_username "$usermap_entry")",
		"access_key": "$(get_access_key "$usermap_entry")",
		"secret_key": "$(get_per_user_secret_key "$local_username")"
	}
EOF
fi
